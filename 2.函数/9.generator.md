## generator

​	generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。

​	ES6定义generator标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。如果你对Python还不熟，赶快恶补[Python教程](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000)！。

​	我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果：

```javascript
function foo(x){
  return x + x;
}
var r = foo(1); // 调用foo函数
```

​	函数在执行过程中，如果没有遇到`return`语句（函数末尾如果没有`return`，就是隐含的`return undefined;`），控制权无法交回被调用的代码。

​	generator跟函数很像，定义如下：

```javascript
function* foo(x){
  yield + 1;
  yield + 2;
  return x + 3；
}
```

​	generator和函数不同的是，generator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。

​	大多数同学立刻就晕了，generator就是能够返回多次的“函数”？返回多次有啥用？

​	还是举个栗子吧。

​	我们以一个著名的斐波那契数列为例，它由`0`，`1`开头：

```javascript
0 1 1 2 3 5 8 13 21 34 ...
```

​	要编写一个产生斐波那契数列的函数，可以这么写：

```javascript
function fib(max){
  var 
  	t,
  	a = 0,
  	b = 1,
  	arr = [0,1];
  	while(arr.length < max){
      t = a + b;
      a = b;
      b = t;
      arr.push(t);
  	}
  	return arr;
}
// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

​	函数只能返回一次，所以必须返回一个`Array`。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下：

```javascript
function* fib(){
  var 
  	t,
  	a=0;
  	b=1;
  	n=1;
  while(n < max){
    yiled a;
    t = a + b;
    a = b;
    b = t;
    n++;
  }
  return a;
}
```

直接调用试试：

```javascript
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
```

​	直接调用一个generator和调用函数不一样，`fib(5)`仅仅是创建了一个generator对象，还没有去执行它。

​	调用generator对象有两个方法，一是不断地调用generator对象的`next()`方法：

```javascript
var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: true}
```

​	`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

​	当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

​	第二个方法是直接用`for ... of`循环迭代generator对象，这种方式不需要我们自己判断`done`：

```javascript
for (var x of fib(5)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3
}
```

​	`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

​	当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

​	第二个方法是直接用`for ... of`循环迭代generator对象，这种方式不需要我们自己判断`done`：

```javascript
for (var x of fib(5)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3
}
```

​	`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。

​	当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。

​	第二个方法是直接用`for ... of`循环迭代generator对象，这种方式不需要我们自己判断`done`：

```javascript
for (var x of fib(5)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3
}
```

​	generator和普通函数相比，有什么用？

​	因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写：

```
var fib = {
  a:0;
  b:1,
  n:0,
  max:5,
  next:function (){
    var 
    r = this.a,
    t = this.a + this.b;
    this.a = this.b;
    this.b = t;
    if(this.n < this.max){
      this.n ++;
      return r;
    }else{
      return undefiend;
    }
  }
}
```


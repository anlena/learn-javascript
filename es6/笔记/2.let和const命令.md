#### let和const命令



1. let命令

   * 基本用法

     ```
     1.let声明的变量只在代码块中有效;
     2.可以为for循环声明值
     ```

   * 不存在变量提升

     ```
     1.var定义的值可以在定义前调用，为undefined。
     2.let定义的值不可以在定义前调用。
     ```

   * 暂时性死区

     ```
     在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”
     ```

   * 不允许重复声明

     ```
     let不允许在相同作用域内，重复声明一个变量。
     因此，不能在相邻层次的函数内部重新声明参数。
     ```

2. 块级作用域

   * 为什么需要块级作用域

     ```
     1.内层变量可能覆盖外层变量(注：if为flase时，内部的赋值会执行获取全局变量)
     2.用来计数的for循环i会泄露为全局变量。
     ```

   * ES6的块级作用域

     ```
     1.let定义的变量不受其他块级层影响({}为块级)
     2.外层作用域无法读取内层作用域的变量
     3.内层作用域可以定义外层作用域的同名变量。
     ```

   * 块级作用域与函数声明

     ```
     1.ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用
     ```

3. const命令

   * 基本用法

     ```
     1.const声明一个只读的常量。一旦声明，常量的值就不能改变。
     2.const的作用域与let命令相同：只在声明所在的块级作用域内有效。
     3.const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
     4.const声明的常量，也与let一样不可重复声明。
     ```

   * 本质

     ```
     1.const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
     2.不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
     3.如果真的想将对象冻结，应该使用Object.freeze方法。
     ```

   * ES6声明变量的6种方法

     ```
     ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。
     ```

4. 顶层对象的属性

   * 顶层对象的属性

     ```
     ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
     ```

5. global属性

